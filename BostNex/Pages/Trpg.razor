@page "/trpg"
@page "/trpg/{pagedata}"
@implements IDisposable
@using Toolbelt.Blazor.HotKeys2
@using Azure.AI.OpenAI;
@using BostNex.Data
@using BostNex.Services
@using BostNex.Pages.Component
@using BostNexShared.Dto
@using Microsoft.Extensions.Options
@inject IOpenAiService _openAi
@inject ITrpgService _trpg
@inject ITrpgFormatService _format
@inject IJSRuntime JS
@inject IOptions<OpenAiOption> _options
@inject HotKeys HotKeys

@* デバッグモード *@
<DebugPanel IsVisible="_display != null && _format.IsDebugMode">
    <Collapse @bind-IsCollapsed="IsCollapsed">
        @* 現在のチャットログ表示 *@
        <ChatGptLogPanel Logs="_openAi.ChatLog" />
        @* プロンプト入力欄 *@
        <PromptPanel OnClickCallback="ResetPrompt" @bind-Text="ResetPromptText">
            <h3>プロンプトの入力</h3>
            <p>チャットログをリセットしてプロンプトを再設定します。<br />@(_options.Value.Separate)で区切ることでUserとAssistantも入力できます。</p>
        </PromptPanel>
    </Collapse>
</DebugPanel>

<PageTitle>@(_display?.Title ?? "Loading")</PageTitle>

@if (!isLoaded)
{
    <div class="spinner-border text-primary">
        <span class="visually-hidden">Loading...</span>
    </div>
    return;
}
else if (_display == null)
{
    <h1>どこにアクセスしとんねん😡</h1>
    return;
}

@* 設定項目があるセッションの場合表示 *@
@if (IsRequiredInputOption)
{
    <OptionPanel IsVisible="IsRequiredInputOption" Action="SubmitOption" Options="_display.Options"></OptionPanel>
    return;
}

<h1>@_display.Headline</h1>
<p><em>@_display.Introduction</em></p>

@* セッションの表示 *@
@{
    // 現在有効なチャットに含まれているか確認する
    var currentChat = _openAi.ChatLog.Where(x => x.Role == ChatRole.Assistant).Select(x => x.Content).ToList();  // AIの返答のみで判定
    foreach (var log in backlogs)
    {
        //  物語の進行ごとに、繰り返して表示する
        <TrpgSessionPanel Session="log" OnSubmitFinished="() => NextSession()" Placeholder="@_display.Placeholder" SubmitText="@_display.SubmitText" CurrentChat="currentChat" />
    }
}

@* TODO:チャット入力欄をこっちに出す。キーボードショートカットに対応させるために。 *@
@if (false)  // TODO:入力可
{
    <InputChatPanel IsSubmitted="IsSubmitted" OnClickCallback="SubmitSessionAsync" Placeholder="@_display.Placeholder" SubmitText="@_display.SubmitText"></InputChatPanel>
}


<div class="my-5"></div>

@code {
    /// <summary>
    /// 画面情報のキー
    /// </summary>
    [Parameter]
    public string? Pagedata { get; set; }

    // サーバから取得した画面情報
    private Display? _display;

    // デバッグモード用
    public bool IsCollapsed { get; set; } = true;

    // ホットキーの設定
    HotKeysContext HotKeysContext = null!;

    // 初期化完了
    private bool isLoaded = false;

    // 設定項目がある場合
    private bool isSubmittedOptions = false;
    private bool IsRequiredInputOption { get => _display != null && _display.Options.Count > 0 && !isSubmittedOptions; }

    private IJSObjectReference? _jsModule = null!;

    /// <summary>今までのセッション</summary>
    private List<TrpgSession> backlogs = new();

    /// <summary>
    /// JSはここでしか読み込めない
    /// </summary>
    /// <param name="firstRender"></param>
    /// <returns></returns>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_jsModule == null) _jsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./Pages/Trpg.razor.js");
        await base.OnAfterRenderAsync(firstRender);
    }

    protected override void OnParametersSet()
    {
        // 初期化
        isLoaded = false;
        _display = null;
        isSubmittedOptions = false;
        IsCollapsed = true;
        backlogs.Clear();
        base.OnParametersSet();

        // ホットキーの設定
        // デフォルトでは入力欄にフォーカスしているとキーを効かなく設定しているので、Exclude.Noneで解除する
        HotKeysContext = this.HotKeys.CreateContext()
          .Add(ModCode.Ctrl, Code.Enter, RequestContinue, "続きを頼む", exclude: Exclude.None)
          .Add(ModCode.Ctrl | ModCode.Shift, Code.Enter, Back, "1回戻す", exclude: Exclude.None)
          .Add(ModCode.Shift, Code.Enter, Submit, "送信", exclude: Exclude.None);

        // パラメータ違いの同じ画面に遷移した場合は、OnInitializedが実行されず、ここが実行されるので注意。
        if (!string.IsNullOrWhiteSpace(Pagedata) && _format.PageData.TryGetValue(Pagedata, out _display!))
        {
            // 人格をセット
            _openAi.InitializeChat(_display);

            // 入力欄を作成
            backlogs.Add(new TrpgSession());
        }
        else
        {
            // 指定されたデータが見つからなかった時
            _display = null;
        }
        isLoaded = true;
        base.OnParametersSet();
    }

    /// <summary>
    /// 設定項目の入力完了
    /// </summary>
    private void SubmitOption()
    {
        isSubmittedOptions = true;
        _openAi.InitializeChat(_display!);
        StateHasChanged();
    }

    /// <summary>
    /// 子コンポーネントでAIメッセージを受信し終わった時の処理
    /// 終了判定
    /// 次のセッションを作成
    /// </summary>
    private async void NextSession()
    {
        backlogs.Add(new TrpgSession());
        StateHasChanged();
        if (_jsModule != null)
        {
            await _jsModule.InvokeVoidAsync("gotoBottom");
        }
    }


    public string ResetPromptText { get; set; } = string.Empty;
    /// <summary>
    /// 開発用
    /// プロンプトを入力されたものに差し替えて再スタート
    /// </summary>
    private void ResetPrompt(string text)
    {
        _openAi.InitializeChat(text);
        backlogs.Clear();
        backlogs.Add(new TrpgSession());
        StateHasChanged();
    }


    // 今は、各Sessionが送信状態を持っているが、テキストを受け取って初めてSessionを作成するように変更。
    // ただし、エラー発生時は送信前に戻さなければならない。
    // 送信中：Sessionを作成してセッションログに追加
    // エラー発生時：セッションログの最後を消す

    /// <summary>
    /// 送信ボタンを押したらtrue、ボタンの制御に使用
    /// <summary>
    public bool IsSubmitted { get; set; } = false;
    // TODO:TrpgSessionクラスからIsSubmittedは削除。

    /// <summary>
    /// 入力したテキストを送信する
    /// </summary>
    /// <returns></returns>
    private async Task SubmitSessionAsync(string input)
    {
        if (IsSubmitted)
        {
            return;
        }

        IsSubmitted = true;

        try
        {
            //new TrpgSession() はこのタイミングで行って、後でストリーミング受信するように変更する。
            var response = await _openAi.GetNextSessionAsync(input);
            //Session.AiResponse = response;
            backlogs.Add(new TrpgSession { Text = input, AiResponse = response });
            IsSubmitted = false;
        }
        catch
        {
            IsSubmitted = false;
            //_isError = true;
            return;
        }

        //// 終わったらバインド元に反映する
        //await SessionChanged.InvokeAsync(Session);

        //// セッションを進めることを親に伝える。
        //if (OnSubmitFinished != null)
        //{
        //    OnSubmitFinished.Invoke();
        //}
    }

    public void Dispose()
    {
        this.HotKeysContext.Dispose();
    }

    /// <summary>送信:Shift+Enter</summary>
    void Submit()
    {
    }
    /// <summary>続きを頼む:Ctrl+Enter</summary>
    void RequestContinue()
    {
    }
    /// <summary>1回戻す:Ctrl+Shift+Enter</summary>
    void Back()
    {
    }
}

